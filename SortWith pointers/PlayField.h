#pragma once
#include <cassert>
#include <vector>

class PlayField {
public:
	enum CellState { csEmpty, csCross, csNought };
	class CellIdx {
	public:
		static CellIdx CreateCell(int x, int y) {
			assert(x >= 0 && y >= 0 && x <= 2 && y <= 2);
			return { x, y };
		}

		int GetX() {
			return x;
		}

		int GetY() {
			return y;
		}
	private:
		int x;
		int y;
		CellIdx(int x, int y) {
			this->x = x;
			this->y = y;
		}
	};
	CellState operator[](CellIdx idx);
	std::vector<CellIdx*> GetEmptyCells();
	enum FieldStatus { fsInvalid, fsNormal, fsCrossesWin, fsNoughtsWin, fsDraw };
	FieldStatus checkFieldStatus();
	PlayField makeMove(CellIdx idx) const;
private:
	PlayField operator+(CellIdx idx);
	CellState state[9] { csEmpty,csEmpty,csEmpty,csEmpty,csEmpty,csEmpty,csEmpty,csEmpty,csEmpty };
	int GetLinearIdxFromCell(CellIdx index) const;
	PlayField::CellIdx GetCellIdxFromLinear(int index) const;
	PlayField::CellState IdentifyWhoseMove() const;
	PlayField::CellState CheckForWin(int* line) const;
};


/*
 * Лабораторная работа №3
 *
 * Темы:
 *     классы (конструкторы, методы, перегрузка операторов),
 *     std::vector (работа с динамическими массивами средствами STL),
 *     cassert.
 *
 * ----------------------------------- Формулировка задания: -----------------------------------
 * Написать программу, которая осуществляет полный обход дерева решений
 * для игры "Крестики-нолики" (Tic Tac Toe/Noughts and Crosses).
 * При этом для каждого возможного первого хода определяет количество
 * выигрышных/проигрышных и ничьих окончаний игры и выводит результат в консоль.
 *
 * При разработке программы каждый класс (кроме вложенных) располагается в своей паре файлов *.h и *.cpp
 *
 * ------- Класс игрового поля PlayField -------
 * Описать и использовать класс игрового поля PlayField.
 * + - Внутри класса PlayField определить и использовать public класс положения клетки CellPos (CellIdx). Определить для
 * + класса CellIdx соответствующие конструкторы, сеттеры, геттеры, по возможности проверять правильность
 * + задаваемых данных. Строки и столбцы нумеруются в диапазоне [0, 2].
 * + - Для PlayField перегрузить public оператор[] для чтения ячеек, возвращающий перечислитель:
 * +   csEmpty - ячейка пуста;
 * +   csCross - в ячейке крестик;
 * +   csNought - в ячейке нолик;
 * +и принимающий в качестве аргумета CellIdx. Перечислитель определить внутри PlayField.
 *  - Для PlayField перегрузить private оператор+ постановки очередной пометки (крестика или нолика),
 * принимающий на вход экземпляры CellIdx и возвращающий экзмепляр поля с новым состоянием игры.
 *  - Определить public метод возврата всех пустых позиций клеток, getEmptyCells, возвращающий массив std::vector
 * с элементами типа CellIdx.
 *  - public Метод проверки состояния поля checkFieldStatus, возвращающий перечислитель:
 *     fsInvalid - состояние поля некорректно (т.е. нельзя дойти до такого состояния соблюдая правила);
 *     fsNormal - состояние поля корректно;
 *     fsCrossesWin - победили крестики;
 *     fsNoughtsWin - победили нолики;
 *     fsDraw - ничья.
 * Данный перечислитель определить внутри класса PlayField.
 *  - Определить public const метод makeMove, который получает позицию клетки CellIdx и возвращает новое поле со
 * сделанным в данной клетке ходом. Если клетка уже заполнена или поле является состоянием конца игры следует
 * вызвать ошибку программы методом cassert.
 *
 * ------- Класс вершины дерева решений TreeNode -------
 * Описать и использовать класс вершины TreeNode дерева решений, несущий в себе const экземпляр текущего состояния
 * игрового поля PlayField, связи с предком и с потомками.
 *  - Для TreeNode определить необходимые конструкторы.
 *  - Определить public метод isTerminal, проверяющий является ли вершина терминальной.
 *  - Определить private метод childQty, определяющий возможное количество потомков на данном уровне дерева.
 *  - Определить public метод addChild добавления нового потомка. Проверять, что потомков не может быть на данном
 * уровне дерева больше, чем положено, в случае попытки добавления большего числа потомков падать с cassert.
 *  - Перегрузить public оператор[], принимающий на вход целое число и возвращающий ссылку на соответствующего потомка,
 * если он существует. Если нет - падать с cassert.
 *  - определить public метод childCount, возвращающий текущее количество потомков у данной вершины.
 *  - определить public метод value, возвращающий const ссылку на состояние поля PlayField в данной вершине дерева.
 *
 * ------- Основная программа -------
 * Решить поставленную задачу используя выше описанные классы.
 * Требования в классам PlayField и TreeNode являются необходимыми и достаточными для решения.
 * Запрещается расширять классы, если нет необходимости. Основания для расширения
 * обязательно пояснять в комментариях к коду.
 * Порядок вывода данных не регламентируется, но он должен быть читаемым и понятным.
*/
